#################################################################################
#		
#		Prefile for plasma glow simulations
#
#			includes:
#			-electron beam 
#			-laser in envelope approximation
#			-multifield structure
#			-beam initialization
#			-MALs
#			-impact ionization from beam and laser generated electrons and impact ionized electrons
#			-H and/or He gas
#
#
#
#
#
##		A.Sutherland
##		based on Tech-X PWFA exampleD and Heinemann and Scherkl 'lightsource.pre'
##
#
#

##-----------------------------------------------------------------------------
##------ Macros ---------------------------------------------------------------
##-----------------------------------------------------------------------------


$ import mathphys
$ import matrix
$ import esSolveOpenBdry
$ import initBeam
$ import absorbingBox
$ import mal
#$ import perfectDispersion
$ import verbosity
verbosity=VP_INFO

$ RESTART = 1
$ BEAM_FIELD_SWITCH = 0 # 0: ElecMultiField = ElecFieldPlasma; 1: ElecMultiField = ElecFieldPlasma + ElecFieldBeam

$ MAX_DUMPS = 0
#  If set to 0, then number of dumps is autogenerated
#  every <AUTO_DUMP> seconds
$ AUTO_DUMP = 0.1e-12
#  Caution, this could lead to huge amount of dumped data!


$ LASER_IONIZATION = 1




##-----------------------------------------------------------------------------
##------ LASER ----------------------------------------------------------------
##-----------------------------------------------------------------------------

## the laser is modeled in the envelope approximation

## laser pulse parameters
$ WAVELENGTH 	= 0.8e-06  	# [m]
$ PULSE_ENERGY 	= 4.92e-3	# [J]
$ W0 		    = 38.e-06	# waist size [m] from Alex' Thesis
$ TAU  	    	= 60.e-15       # fwhm pulse length of Intensity!! [s] From Alex' thesis
$ ySHIFT    	= 0.0		# y-shift  at focus
$ zSHIFT     	= 0.0e-6		# z-shift  at focus
$ xFOCUS        = 1.4e-3   		# laser focus position
$ xy_PHI        = 90.0		# angle between x and y axis. in deg (this is not the same definition as in the old TH prefiles!)


## target laser pulse delay to e-beam
# zero means laser front and e-beam center coincide on axis
$ L_DELAY = -2.0e-12		# seconds!!	# - means laser before ebeam
$ ADDTIME = 20.e-12 


##-----------------------------------------------------------------------------
##------ Electron BUNCH -------------------------------------------------------
##-----------------------------------------------------------------------------

# basic beam parameters
$ BEAM_CHARGE	        = 3.2e-9		# total beam charge [C]
$ BEAM_RMS_LENGTH	= 63.6e-06		# [m]
$ BEAM_RMS_WIDTH_Y	= 21.8e-06		# [m]
$ BEAM_RMS_WIDTH_Z	= 44.4e-06		# [m]
$ BEAM_ENERGY	 	= 21.3e9		# [eV], not MeV!!
# normalized emittance
$ EPSILON_RMS_N 	= 2.25e-06    	# [m-rad]
# rel. lingitudinal rms energy spread
$ DE_OVER_E_RMS	= 0.02		

# vertical and horizontal beam offset with respect to koordinate center:
# use this to implement an artificial "misalignment"
$ BEAM_OFFSET_LONG = -700.e-6
$ BEAM_OFFSET_VERT = 100.e-6
$ BEAM_OFFSET_HOR  = 0.0e-6

$ BEAM_PTCLS_PER_CELL =  16.	# set according to desired resolution


$ BEAM_INIT_RANGE_Y = 0.8e-3
$ BEAM_INIT_RANGE_Z = 0.8e-3
##-----------------------------------------------------------------------------
##------ BACKGROUND GAS -------------------------------------------------------
##-----------------------------------------------------------------------------


## choose Hydrogen flag
#  -1: remove all Hydrogen
#   1: keep neutral Hydrogen everywhere, but no plasma channel
$ H_FLAG =  1

$ H_DENS = 1.252e+23
$ H_DENS = 1.852e+23




# choose Helium flag:
#  -1: remove all Helium from the simulation
#   1: add neutral Helium everywhere
$ HE_FLAG = 0 
$ HE_DENS = 6.26e22	# Olli for dataset 20384: p = 3.945 torr



$ GAS_RAMPLEN = 300.e-6
$ GAS_DISTANCE_WALLS   = 50.0e-6            # number of cells away from box boundary where density ramp will start




## specify particles per cell
# -------------------------------------
# must be at least 1, increase the number in case of low-resolution runs
$ NP_X = 2
$ NP_Y = 2
$ NP_Z = 2
$ PPC_0 = 1.*NP_X*NP_Y*NP_Z	# don't touch this, trust me :)
# -------------------------------------

## set background density
# (explicitly used to derive the plasma wavelength)
$ BG_DENS = H_DENS

## calculate plasma wavelength
# (can be used to derive the box dimensions)
$ LAMBDA_PE = 3.34e+07 / sqrt(BG_DENS)
# -------------------------------------




##-----------------------------------------------------------------------------
##------ GRID -----------------------------------------------------------------
##-----------------------------------------------------------------------------

## set box size
$   LX_TEMP = 3000.e-6		# N_MAL_X*DX
$   LY_TEMP = 2800.e-6		# N_MAL*2*DY
$   LZ_TEMP = 800.e-6		# N_MAL*2*DZ


## cell size [m]
# set to desired resolution.
# you might want to adapt the number of particles and the MALs accordingly
$ DX = 8.e-6
$ DY = 8.e-6
$ DZ = 8.e-6

$ DXI = 1./DX
$ DYI = 1./DY
$ DZI = 1./DZ

## number of cells
$ NX = int(LX_TEMP/DX)
$ NY = int(LY_TEMP/DY)
$ NZ = int(LZ_TEMP/DZ)

## grid lengths
$ LX = NX * DX
$ LY = NY * DY
$ LZ = NZ * DZ


## simulation boundaries
# -------------------------------------
$ XSTART = -0.5 * LX + 200.e-6	# initialize the beam later at x = 0
$ YSTART = -0.5 * LY    # this puts y=0. and z=0. in the center of the grid
$ ZSTART = -0.5 * LZ

$ XEND = XSTART + LX
$ YEND = YSTART + LY
$ ZEND = ZSTART + LZ
# -------------------------------------

## time step
# -------------------------------------
# since there is no laser, there is no urgent need to get close to the
# courant limit. Instead, the "special" timestep of Godfrey and Vay is used.
# They concluded that this helps mitigating numerical instabilities in the bunch.
$ DS = 1. / sqrt(DXI*DXI + DYI*DYI + DZI*DZI)

#$ DT = 0.9998 * DS / LIGHTSPEED
$ DT = 0.5 * DX / LIGHTSPEED
# -------------------------------------


####	-->> end of user input






##-----------------------------------------------------------------------------
##------ AUXILIARY CALCULATIONS -----------------------------------------------
##-----------------------------------------------------------------------------

$ NDIM = 3 # dont change, not 2D implemented


## setup for specifying the MAL algorithm
# -------------------------------------


$ MAL_DAMP_AMPLITUDE 	  = 1.0		# default is 0.5, recommended 0.125 - 2.0
$ MAL_DAMP_ORDER		  = 3.		# default is 3., recommended 1. - 4.

# number of cells allocated for MALs (along each edge)
$ N_MAL_Y = int(abs(GAS_RAMPLEN + GAS_DISTANCE_WALLS +DY)/DY)		# change according to resolution
$ N_MAL_Z = 20					# half the cell size --> double the number of MALs
$ N_MALX  = 0

$ NX_BEG = 0      	 # no PMLs along the x-axis
$ NY_BEG = N_MAL_Y
$ NZ_BEG = N_MAL_Z

$ NX_END = NX     
$ NY_END = NY - N_MAL_Y
$ NZ_END = NZ - N_MAL_Z

## later used for boundaries of MALs
$ NX1 = NX + 1
$ NY1 = NY + 1
$ NZ1 = NZ + 1
# -------------------------------------



## additional bunch parameters
# -------------------------------------
# velocities
$ 	GAMMA_BEAM		= BEAM_ENERGY / ELECMASSEV + 1.0
$	BETA_BEAM		= sqrt(1. - 1. / GAMMA_BEAM**2)
$	V_X_AVG			= BETA_BEAM  * LIGHTSPEED
$	U_X_AVG			= GAMMA_BEAM * V_X_AVG
$	U_X_RMS			= DE_OVER_E_RMS * U_X_AVG
$	U_Y_RMS			= LIGHTSPEED * EPSILON_RMS_N / BEAM_RMS_WIDTH_Y
$	U_Z_RMS			= LIGHTSPEED * EPSILON_RMS_N / BEAM_RMS_WIDTH_Z
# beam peak density
$	N_TOTAL 		= BEAM_CHARGE / ELEMCHARGE
$	LONG_NORM		= 1.0 / ( sqrt(TWOPI) * BEAM_RMS_LENGTH )
$	PERP_NORM_Y		= 1.0 / ( sqrt(TWOPI) * BEAM_RMS_WIDTH_Y )
$	PERP_NORM_Z		= 1.0 / ( sqrt(TWOPI) * BEAM_RMS_WIDTH_Z )
$	BEAM_DENSITY	= N_TOTAL * LONG_NORM * PERP_NORM_Y * PERP_NORM_Z
# -------------------------------------

## beam initialization conditions
# -------------------------------------
$ BEAM_CENTER 		= 0. + BEAM_OFFSET_LONG
$ BEAM_HALF_LENGTH 	= 4 * BEAM_RMS_LENGTH
$ BEAM_LOAD_XSTART 	= BEAM_CENTER - BEAM_HALF_LENGTH
$ BEAM_LOAD_XEND 	= BEAM_CENTER + BEAM_HALF_LENGTH
$ MAX_RAD_Y			= 4.0 * BEAM_RMS_WIDTH_Y
$ MAX_RAD_Z			= 4.0 * BEAM_RMS_WIDTH_Z
# -------------------------------------




# -------------------------------------
## moving window start
$ MW_SHIFT_POSITION = 0.
# -------------------------------------

## laser delay / correction offset
# -------------------------------------
$ DEL_OFFSET = BEAM_CENTER / LIGHTSPEED 	# shift the beam center to t0
$ LB_DELAY = L_DELAY + DEL_OFFSET
# -------------------------------------




## laser definition and shape
# -------------------------------------
#  norm. amplitude:
$ A0 		= 6.61156641e-6 * WAVELENGTH * sqrt(PULSE_ENERGY/TAU/W0**2)
$ FREQUENCY	= LIGHTSPEED/WAVELENGTH
$ K_LASER	= 2.*PI/WAVELENGTH
$ OMEGA		= 2.*PI*FREQUENCY
$ EoverA    = ELECMASS*OMEGA*LIGHTSPEED/ELEMCHARGE
$ E0   		= A0 * EoverA		# peak E-field
$ xR  		= PI*W0**2/WAVELENGTH	# Rayleigh length
$ L_FWHM 	= TAU * LIGHTSPEED    	# fwhm pulse length [m]
$ xRMS		= L_FWHM/2.355		    # rms pulse length [m]


# squared waist function w(x)^2
#   w0 is the rms spot size at focus
#   xR0 is the Rayleigh length
  <function waistsq(xArg,w0,xR0)>
    w0**2 * (1.+(xArg/xR0)**2)
  </function>

# longitudinal waist evolution waistevol() = w0/w(x)
#   xR0 is the Rayleigh length
  <function waistevol(xArg,xR0)>
    1./sqrt(1.+(xArg/xR0)**2)
  </function>

# laser pulse center (drifting with velocity c)
#   tW is the time at which focus is reached
  <function pulseCenter(tArg,tW)>
    (tArg-tW) * LIGHTSPEED
  </function>

# drifting, Gaussian longitudinal (temporal) envelope
# longenvelope() = exp(-1/2 * (x-xcenter)^2/xrms^2))
#   tW is the time at which focus is reached
#   xRMS0 is the rms pulse length (squared)
# here, the sqare root translates RMS pulse length from intensity to electric field
  <function longenvelope(xArg,tArg,tW,xRMS0)>
    sqrt(exp(-0.5*((xArg-pulseCenter(tArg,tW))/xRMS0)**2))
#     exp(-0.5*((xArg-pulseCenter(tArg,tW))/xRMS0)**2)
  </function>

# evolving transverse field distribution
# transenvelope() = exp(-(r^2/waist(x)^2)
#   xR0 is the Rayleigh range
#   w0 is the rms laser spot size at focus
  <function transenvelope(xArg,yArg,zArg,w0,xR0)>
    exp(-(yArg**2+zArg**2)/waistsq(xArg,w0,xR0))
  </function>

# laser envelope formula
#   xR0 is the Rayleigh range
#   w0 is laser pulse spot size at the waist
#   tW is the time at which focus is reached
#   xRMS is the rms pulse length (intensity)
#   EP is the peak electric field
  <function laserenvelope(xArg,yArg,zArg,tArg,xR0,w0,tW,xRMS,EP)>
    EP * waistevol(xArg,xR0)				\
       * longenvelope(xArg,tArg,tW,xRMS)		\
       * transenvelope(xArg,yArg,zArg,w0,xR0)
  </function>

$ pFAC = TWOPI / 360.

# coordinate shift functions
<function tFOCUS(laser_xFocus, laser_delay)>
  (laser_xFocus-BEAM_CENTER)/LIGHTSPEED + laser_delay 
</function>




$ pFAC = TWOPI / 360.
<function x1(x0,y0, laser_xFocus, laser_ySHIFT, xy_angle)>
                    
  (x0-laser_xFocus)*cos(pFAC*xy_angle) + (y0-laser_ySHIFT)*sin(pFAC*xy_angle)
</function>

<function y1(x0,y0, laser_xFocus, laser_ySHIFT, xy_angle)>
                    
  (laser_xFocus-x0)*sin(pFAC*xy_angle) + (y0-laser_ySHIFT)*cos(pFAC*xy_angle)
</function>

<function z1(z0, laser_zSHIFT)>
  (z0-laser_zSHIFT)
</function>

# -------------------------------------



## moving window stopper
# -------------------------------------
$	MW_STOPPOS = xFOCUS - N_MALX*DX / 2. 
	  <OAFunc shiftSpeed>
		kind = expression
		expression = LIGHTSPEED * H( MW_STOPPOS / LIGHTSPEED - t )
		variable = t
	  </OAFunc>




## simulation time and dumps
# -------------------------------------
$   SIMTIME   = MW_STOPPOS / LIGHTSPEED + ADDTIME
$ 	if MAX_DUMPS == 0
$   	NDUMPS    = int(SIMTIME / AUTO_DUMP)
$ 	else
$  		NDUMPS    = int(MAX_DUMPS)
$ 	endif

$   NSTEP_TMP = int(SIMTIME / DT)
$   DUMP_PER  = int(NSTEP_TMP / NDUMPS)
$   NSTEPS    = NDUMPS * DUMP_PER
# -------------------------------------




##-----------------------------------------------------------------------------
##------ VORPAL IMPLEMENTATION ------------------------------------------------
##-----------------------------------------------------------------------------


dimension = NDIM
floattype = double

dt 				= DT
nsteps 			= NSTEPS
dumpPeriodicity	= DUMP_PER

# moving window
downShiftDir = 0                   # x-direction
downShiftPos = MW_SHIFT_POSITION   # delay = downShiftPos/c

							 
<Grid globalGrid>
  numCells       = [ NX     NY     NZ    ]
  lengths        = [ LX     LY     LZ    ]
  startPositions = [ XSTART YSTART ZSTART ]
  maxIntDepHalfWidth = 2
</Grid>

# turn off the "comms" text files (they can be useful for debugging)
noComms = 1

## domain decomposition
<Decomp decomp>
 kind = regular
</Decomp>





## --------------------------------------------------
## Multifield
## --------------------------------------------------

<MultiField emField>
  #-----------------------------------------------------------------------
  # Fields and Boundary Conditions
  #-----------------------------------------------------------------------

  # charge density deposited by the particle beam
  <Field rhoBeam>
    kind = depField
    numComponents = 1
    overlap = [2 3]
    offset = none
  </Field>

  # current deposited by the particle beam
  <Field JBeam>
    kind = depField
    numComponents = 3
    overlap = [2 3]
    offset = edge
  </Field>

  # Electric field for the beam
  <Field ElecFieldBeam>
    numComponents = 3
    overlap = [2 3]
    offset = edge
    interpolation = esirk3rdOrder
	
    <BoundaryCondition BeamleftConductorBack>  # left edge of 'back' MALs
      lowerBounds = [ 0   -1       -1]
      upperBounds = [ 1   NY_BEG  NZ1]
      kind        = constant
      minDim      = 2
      components  = [1  2 ]    # both Ey and Ez
      amplitudes  = [0. 0.]
    </BoundaryCondition>

    <BoundaryCondition BeamleftConductorBottom>  # left edge of 'bottom' MALs
      lowerBounds = [ 0    -1   -1    ]
      upperBounds = [ 1   NY1   NZ_BEG]
      kind        = constant
      minDim      = 3
      components  = [1  2 ]    # both Ey and Ez
      amplitudes  = [0. 0.]
    </BoundaryCondition>

    <BoundaryCondition BeamleftConductorMiddle>
      lowerBounds = [0  NY_BEG  NZ_BEG]
      upperBounds = [1  NY_END  NZ_END]
      kind        = constant
      minDim      = 2
      components  = [1  2 ]    # both Ey and Ez
      amplitudes  = [0. 0.]
    </BoundaryCondition>

    <BoundaryCondition BeamleftConductorFront>  # left edge of 'front' MALs
      lowerBounds = [ 0   NY_END   -1]
      upperBounds = [ 1   NY1     NZ1]
      kind        = constant
      minDim      = 2
      components  = [1  2 ]    # both Ey and Ez
      amplitudes  = [0. 0.]
    </BoundaryCondition>

    <BoundaryCondition BeamleftConductorTop>  # left edge of 'top' MALs
      lowerBounds = [ 0    -1    NZ_END]
      upperBounds = [ 1   NY1    NZ1   ]
      kind        = constant
      minDim      = 3
      components  = [1  2 ]    # both Ey and Ez
      amplitudes  = [0. 0.]
    </BoundaryCondition>
 
    <BoundaryCondition BeamrightConductor>
      lowerBounds = [NX    0   0]
      upperBounds = [NX1  NY  NZ]
      kind        = constant
      components  = [1  2 ]    # both Ey and Ez
      amplitudes  = [0. 0.]
    </BoundaryCondition>

    <BoundaryCondition BeamfrontConductor>
      lowerBounds = [ 0   0   0]
      upperBounds = [NX   1  NZ]
      minDim      = 2
      kind        = constant
      components  = [1  2 ]    # both Ey and Ez
      amplitudes  = [0. 0.]
    </BoundaryCondition>

    <BoundaryCondition BeambackConductor>
      lowerBounds = [ 0  NY    0]
      upperBounds = [NX  NY1  NZ]
      minDim      = 2
      kind        = constant
      components  = [0  2 ]    # both Ex and Ez
      amplitudes  = [0. 0.]
    </BoundaryCondition>

    <BoundaryCondition BeambottomConductor>
      lowerBounds = [ 0    0   0]
      upperBounds = [NX   NY   1]
      minDim      = 3
      kind        = constant
      components  = [0  1 ]    # both Ex and Ey
      amplitudes  = [0. 0.]
    </BoundaryCondition>
 
    <BoundaryCondition BeamtopConductor>
      lowerBounds = [ 0    0   NZ ]
      upperBounds = [NX   NY   NZ1]
      minDim      = 3
      kind        = constant
      components  = [0  1 ]    # both Ex and Ey
      amplitudes  = [0. 0.]
    </BoundaryCondition>
  
  </Field>

  # Magnetic field for the beam
  <Field MagFieldBeam>
    numComponents = 3
    overlap = [2 3]
    offset = face
    interpolation = esirk3rdOrder
  </Field>

  # charge density deposited by the plasma
  <Field rhoPlasma>
    kind = depField
    numComponents = 1
    overlap = [2 3]
    offset = none
  </Field>

  # current deposited by the plasma
  <Field JPlasma>
    kind = depField
    numComponents = 3
    overlap = [2 3]
    offset = edge
  </Field>

  # Electric field for the plasma
  <Field ElecFieldPlasma>
    numComponents = 3
    overlap = [2 3]
    offset = edge
    interpolation = esirk3rdOrder
	
    <BoundaryCondition PlasmaleftConductorBack>  # left edge of 'back' MALs
      lowerBounds = [ 0   -1       -1]
      upperBounds = [ 1   NY_BEG  NZ1]
      kind        = constant
      minDim      = 2
      components  = [1  2 ]    # both Ey and Ez
      amplitudes  = [0. 0.]
    </BoundaryCondition>

    <BoundaryCondition PlasmaleftConductorBottom>  # left edge of 'bottom' MALs
      lowerBounds = [ 0    -1   -1    ]
      upperBounds = [ 1   NY1   NZ_BEG]
      kind        = constant
      minDim      = 3
      components  = [1  2 ]    # both Ey and Ez
      amplitudes  = [0. 0.]
    </BoundaryCondition>

    <BoundaryCondition PlasmaleftConductorMiddle>
      lowerBounds = [0  NY_BEG  NZ_BEG]
      upperBounds = [1  NY_END  NZ_END]
      kind        = constant
      minDim      = 2
      components  = [1  2 ]    # both Ey and Ez
      amplitudes  = [0. 0.]
    </BoundaryCondition>

    <BoundaryCondition PlasmaleftConductorFront>  # left edge of 'front' MALs
      lowerBounds = [ 0   NY_END   -1]
      upperBounds = [ 1   NY1     NZ1]
      kind        = constant
      minDim      = 2
      components  = [1  2 ]    # both Ey and Ez
      amplitudes  = [0. 0.]
    </BoundaryCondition>

    <BoundaryCondition PlasmaleftConductorTop>  # left edge of 'top' MALs
      lowerBounds = [ 0    -1    NZ_END]
      upperBounds = [ 1   NY1    NZ1   ]
      kind        = constant
      minDim      = 3
      components  = [1  2 ]    # both Ey and Ez
      amplitudes  = [0. 0.]
    </BoundaryCondition>
 
    <BoundaryCondition PlasmarightConductor>
      lowerBounds = [NX    0   0]
      upperBounds = [NX1  NY  NZ]
      kind        = constant
      components  = [1  2 ]    # both Ey and Ez
      amplitudes  = [0. 0.]
    </BoundaryCondition>

    <BoundaryCondition PlasmafrontConductor>
      lowerBounds = [ 0   0   0]
      upperBounds = [NX   1  NZ] 
      minDim      = 2
      kind        = constant
      components  = [1  2 ]    # both Ey and Ez
      amplitudes  = [0. 0.]
    </BoundaryCondition>

    <BoundaryCondition PlasmabackConductor>
      lowerBounds = [ 0  NY    0]
      upperBounds = [NX  NY1  NZ]
      minDim      = 2
      kind        = constant
      components  = [0  2 ]    # both Ex and Ez
      amplitudes  = [0. 0.]
    </BoundaryCondition>

    <BoundaryCondition PlasmabottomConductor>
      lowerBounds = [ 0    0   0]
      upperBounds = [NX   NY   1]
      minDim      = 3
      kind        = constant
      components  = [0  1 ]    # both Ex and Ey
      amplitudes  = [0. 0.]
    </BoundaryCondition>
 
    <BoundaryCondition PlasmatopConductor>
      lowerBounds = [ 0    0   NZ ]
      upperBounds = [NX   NY   NZ1]
      minDim      = 3
      kind        = constant
      components  = [0  1 ]    # both Ex and Ey
      amplitudes  = [0. 0.]
    </BoundaryCondition>

  </Field>

 # Magnetic field for the beam
  <Field MagFieldPlasma>
    numComponents = 3
    overlap = [2 3]
    offset = face
    interpolation = esirk3rdOrder		 
  </Field>


  # laser electric field
  <Field ElecFieldLaser>
    numComponents = 3
    overlap = [2 3]
    offset = edge
    interpolation = esirk3rdOrder	 
  </Field>


  # Electric field sum on edges
  <Field ElecMultiField>
    numComponents = 3
    overlap = [2 3]
    offset = edge
    interpolation = esirk3rdOrder
						 
  </Field>

  # Magnetic field sum on faces
  <Field MagMultiField>
    numComponents = 3
    overlap = [2 3]
    offset = face
    interpolation = esirk3rdOrder
  </Field>

  #-----------------------------------------------------------------------
  # Field Updaters
  #-----------------------------------------------------------------------

  # Ampere update
  <FieldMultiUpdater yeeAmpereBeam>
    kind        = yeeAmpereUpdater
    lowerBounds = [ 0    0     0  ]
    upperBounds = [NX    NY    NZ ]
    readFields  = [MagFieldBeam JBeam]
    readFieldCompShifts = [0 0]
    writeFields = [ElecFieldBeam]
    components  = [ 0  1  2 ]
    contractFromBottomInNonComponentDir = 1
  </FieldMultiUpdater>

  # Faraday update
  <FieldMultiUpdater yeeFaradayBeam>
    expandToTopInComponentDir = 1
    kind        = yeeFaradayUpdater
    components  = [ 0  1  2 ]
    readFields  = [ElecFieldBeam]
    writeFields = [MagFieldBeam]
    lowerBounds = [ 0   0   0  ]
    upperBounds = [NX   NY  NZ  ]
  </FieldMultiUpdater>

  # Ampere update
  <FieldMultiUpdater yeeAmperePlasma>
    kind        = yeeAmpereUpdater
    lowerBounds = [ 0    0     0  ]
    upperBounds = [NX    NY    NZ ]
    readFields  = [MagFieldPlasma JPlasma]
    readFieldCompShifts = [0 0]
    writeFields = [ElecFieldPlasma]
    components  = [ 0  1  2 ]
    contractFromBottomInNonComponentDir = 1
  </FieldMultiUpdater>

  # Faraday update
  <FieldMultiUpdater yeeFaradayPlasma>
    expandToTopInComponentDir = 1
    kind        = yeeFaradayUpdater
    components  = [ 0  1  2 ]
    readFields  = [ElecFieldPlasma]
    writeFields = [MagFieldPlasma]
    lowerBounds = [ 0   0   0  ]
    upperBounds = [NX   NY  NZ  ]
  </FieldMultiUpdater>

  <FieldMultiUpdater initialLaserLauncher0>
    minDim = 3
    kind = STFuncUpdater
    operation = set
    #velOverC = -1.0
    lowerBounds = [ 0    0    0    ]
    upperBounds = [NX    NY    NZ ]
    components = [0]
    writeComponents = [0] 
    writeFields = [ElecFieldLaser]
    <STFunc component0>
      kind = expression
      expression = 0.0
    </STFunc>
  </FieldMultiUpdater>

  <FieldMultiUpdater initialLaserLauncher1>
    minDim = 3
    kind = STFuncUpdater
    operation = set
    #velOverC = -1.0
    lowerBounds = [ 0    0    0    ]
    upperBounds = [NX    NY    NZ ]
    components = [2]
    writeComponents = [2] 
    writeFields = [ElecFieldLaser]
    <STFunc component1>
      kind = expression
      expression = 0.0
    </STFunc>
  </FieldMultiUpdater>
  
  <FieldMultiUpdater LaserLauncher1>
    minDim = 3
    kind = STFuncUpdater
    operation = set
    #velOverC = -1.0
    lowerBounds = [ 0    0    0    ]
    upperBounds = [NX    NY    NZ ]
    components = [2]
    writeComponents = [2] 
    writeFields = [ElecFieldLaser]
     <STFunc component2>
 	  kind = expression
          expression = laserenvelope(x1(x,y, xFOCUS, ySHIFT, xy_PHI),y1(x,y, xFOCUS, ySHIFT, xy_PHI),z1(z, zSHIFT),t,xR, W0, tFOCUS(xFOCUS, L_DELAY),xRMS, E0)
     </STFunc>
  </FieldMultiUpdater>
  
  
  
  <FieldUpdater sumE1>
     kind = fieldBinOpUpdater
     lowerBounds = [ 0     0     0   ]
     upperBounds = [ NX    NY    NZ  ]
     binOp = add
     aCoeff = 1.0
     bCoeff = 1.0
     readFields = [ElecFieldBeam ElecFieldPlasma]
     writeFields = [ElecMultiField]
   </FieldUpdater>

  <FieldUpdater sumE2>
     kind = fieldBinOpUpdater
     lowerBounds = [ 0     0     0   ]
     upperBounds = [ NX    NY    NZ  ]
     binOp = add
     aCoeff = 0.0
     bCoeff = 1.0
     readFields = [ElecFieldBeam ElecFieldPlasma]
     writeFields = [ElecMultiField]
   </FieldUpdater>



   <FieldUpdater sumB1>
     kind = fieldBinOpUpdater
     lowerBounds = [ 0     0     0    ]
     upperBounds = [ NX    NY    NZ   ]
     binOp = add
     aCoeff = 1.0
     bCoeff = 1.0
     readFields = [MagFieldBeam MagFieldPlasma]
     writeFields = [MagMultiField]
   </FieldUpdater>

   <FieldUpdater sumB2>
     kind = fieldBinOpUpdater
     lowerBounds = [ 0     0     0    ]
     upperBounds = [ NX    NY    NZ   ]
     binOp = add
     aCoeff = 0.0
     bCoeff = 1.0
     readFields = [MagFieldBeam MagFieldPlasma]
     writeFields = [MagMultiField]
   </FieldUpdater>



  # -------------------------------------------------------------
  # Initialization
  # -------------------------------------------------------------
$ if RESTART == 0
    # fields, updater and update steps for the beam field initialization
    $ BEAM_INIT_START_X = int( abs(XSTART - (BEAM_CENTER - BEAM_HALF_LENGTH*1.1))/DX ) # cell index in X where beamInit should start
    $ if BEAM_INIT_START_X < 0
    $  BEAM_INIT_START_X = 0
    $ endif
    
    $ BEAM_INIT_END_X   = int( abs(XSTART - (BEAM_CENTER + BEAM_HALF_LENGTH*1.1))/DX ) # cell index in X where beamInit should end
    $ if BEAM_INIT_END_X > NX
      $ BEAM_INIT_END_X = NX
    $ endif
  
    $ if LY_TEMP > 1.0e-3
      $ BEAM_INIT_START_Y = int( abs(YSTART - (BEAM_OFFSET_VERT - BEAM_INIT_RANGE_Y))/DY ) # cell index in Y where beamInit should start
      $ BEAM_INIT_END_Y   = int( abs(YSTART - (BEAM_OFFSET_VERT + BEAM_INIT_RANGE_Y))/DY ) # cell index in Y where beamInit should end
    $ else
      $ BEAM_INIT_START_Y = 0
      $ BEAM_INIT_END_Y   = NY
    $ endif 
  
    $ if LZ_TEMP > 1.0e-3
       $ BEAM_INIT_START_Z = int( abs(ZSTART - (BEAM_OFFSET_HOR - BEAM_INIT_RANGE_Z))/DZ ) # cell index in X where beamInit should start
       $ BEAM_INIT_END_Z   = int( abs(ZSTART - (BEAM_OFFSET_HOR + BEAM_INIT_RANGE_Z))/DZ ) # cell index in X where beamInit should end
    $else
       $ BEAM_INIT_START_Z = 0
       $ BEAM_INIT_END_Z   = NZ
    $ endif 

  
  initBeam(rhoBeam, ElecFieldBeam, MagFieldBeam, GAMMA_BEAM, BEAM_INIT_START_X, BEAM_INIT_START_Y, BEAM_INIT_START_Z, BEAM_INIT_END_X, BEAM_INIT_END_Y, BEAM_INIT_END_Z, DX, DY, DZ, NDIM, 0)
$ endif

  <InitialUpdateStep step9.7>
    toDtFrac = 1.0
    updaters = [initialLaserLauncher0]
    messageFields = [ElecFieldLaser]
  </InitialUpdateStep>
  
  <InitialUpdateStep step9.71>
    toDtFrac = 1.0
    updaters = [initialLaserLauncher1]
    messageFields = [ElecFieldLaser]
  </InitialUpdateStep>

$ if BEAM_FIELD_SWITCH == 1
  <InitialUpdateStep step9.81>
    toDtFrac = 0.0
    messageFields = [ElecMultiField]
    updaters = [sumE1]
  </InitialUpdateStep>
$ endif


$ if BEAM_FIELD_SWITCH == 0
  <InitialUpdateStep step9.82>
    toDtFrac = 0.0
    messageFields = [ElecMultiField]
    updaters = [sumE2]
  </InitialUpdateStep>
$ endif

$ if BEAM_FIELD_SWITCH == 1
  <InitialUpdateStep step9.9>
    toDtFrac = 1.0
    messageFields = [MagMultiField]
    updaters = [sumB1]
  </InitialUpdateStep>
$ endif

$ if BEAM_FIELD_SWITCH == 0
  <InitialUpdateStep step9.91>
    toDtFrac = 1.0
    messageFields = [MagMultiField]
    updaters = [sumB2]
  </InitialUpdateStep>
$ endif

 # -------------------------------------------------------------
 # Update steps, including MALs
 # -------------------------------------------------------------

 
  MALdampB_beforeFaraday(MagFieldPlasma,malb1yL, 0, 0, 0,      NX, NY_BEG, NZ, 1, -1, YSTART, DY, MAL_DAMP_AMPLITUDE, MAL_DAMP_ORDER)
  MALdampB_beforeFaraday(MagFieldPlasma,malb1yU, 0, NY_END, 0, NX, NY,    NZ, 1,  1, YSTART, DY, MAL_DAMP_AMPLITUDE, MAL_DAMP_ORDER)
  MALdampB_beforeFaraday(MagFieldPlasma,malb1zL, 0, NY_BEG, 0,      NX, NY_END, NZ_BEG, 2, -1, ZSTART, DZ, MAL_DAMP_AMPLITUDE, MAL_DAMP_ORDER)
  MALdampB_beforeFaraday(MagFieldPlasma,malb1zR, 0, NY_BEG, NZ_END, NX, NY_END,    NZ, 2,  1, ZSTART, DZ, MAL_DAMP_AMPLITUDE, MAL_DAMP_ORDER)
  



  
  
$ if BEAM_FIELD_SWITCH == 1
  MALdampB_beforeFaraday(MagFieldBeam,malb1yL, 0, 0, 0,      NX, NY_BEG, NZ, 1, -1, YSTART, DY, MAL_DAMP_AMPLITUDE, MAL_DAMP_ORDER)
  MALdampB_beforeFaraday(MagFieldBeam,malb1yU, 0, NY_END, 0, NX, NY,    NZ, 1,  1, YSTART, DY, MAL_DAMP_AMPLITUDE, MAL_DAMP_ORDER)
  MALdampB_beforeFaraday(MagFieldBeam,malb1zL, 0, NY_BEG, 0,      NX, NY_END, NZ_BEG, 2, -1, ZSTART, DZ, MAL_DAMP_AMPLITUDE, MAL_DAMP_ORDER)
  MALdampB_beforeFaraday(MagFieldBeam,malb1zR, 0, NY_BEG, NZ_END, NX, NY_END,    NZ, 2,  1, ZSTART, DZ, MAL_DAMP_AMPLITUDE, MAL_DAMP_ORDER)
$ endif

  <UpdateStep step10>
     toDtFrac      = 0.5
     messageFields = [MagFieldPlasma]
     updaters      = [yeeFaradayPlasma]
   </UpdateStep>

$ if BEAM_FIELD_SWITCH == 1
   <UpdateStep step11>
      toDtFrac      = 0.5
      messageFields = [MagFieldBeam]
      updaters      = [yeeFaradayBeam]
    </UpdateStep>
$ endif


  MALdampE_beforeAmpere(ElecFieldPlasma, male1yL, 0, 0, 0,      NX, NY_BEG, NZ, 1, -1, YSTART, DY, MAL_DAMP_AMPLITUDE, MAL_DAMP_ORDER)
  MALdampE_beforeAmpere(ElecFieldPlasma, male1yU, 0, NY_END, 0, NX, NY,    NZ, 1,  1, YSTART, DY, MAL_DAMP_AMPLITUDE, MAL_DAMP_ORDER)
  MALdampE_beforeAmpere(ElecFieldPlasma,male1zL, 0, NY_BEG, 0,      NX, NY_END, NZ_BEG, 2, -1, ZSTART, DZ, MAL_DAMP_AMPLITUDE, MAL_DAMP_ORDER)
  MALdampE_beforeAmpere(ElecFieldPlasma,male1zR, 0, NY_BEG, NZ_END, NX, NY_END,    NZ, 2,  1, ZSTART, DZ, MAL_DAMP_AMPLITUDE, MAL_DAMP_ORDER)

  
  
$ if BEAM_FIELD_SWITCH == 1

  MALdampE_beforeAmpere(ElecFieldBeam, male1yL, 0, 0, 0,      NX, NY_BEG, NZ, 1, -1, YSTART, DY, MAL_DAMP_AMPLITUDE, MAL_DAMP_ORDER)
  MALdampE_beforeAmpere(ElecFieldBeam, male1yU, 0, NY_END, 0, NX, NY,    NZ, 1,  1, YSTART, DY, MAL_DAMP_AMPLITUDE, MAL_DAMP_ORDER)
  MALdampE_beforeAmpere(ElecFieldBeam,male1zL, 0, NY_BEG, 0,      NX, NY_END, NZ_BEG, 2, -1, ZSTART, DZ, MAL_DAMP_AMPLITUDE, MAL_DAMP_ORDER)
  MALdampE_beforeAmpere(ElecFieldBeam,male1zR, 0, NY_BEG, NZ_END, NX, NY_END,    NZ, 2,  1, ZSTART, DZ, MAL_DAMP_AMPLITUDE, MAL_DAMP_ORDER)

$ endif
  
  
  <UpdateStep laser1>
    toDtFrac = 1.0
    updaters = [LaserLauncher1]
    messageFields = [ElecFieldLaser]
  </UpdateStep>
  <UpdateStep step13>
    toDtFrac      = 1.0
    messageFields = [ElecFieldPlasma]
    updaters      = [ yeeAmperePlasma]
  </UpdateStep>

$ if BEAM_FIELD_SWITCH == 1

  <UpdateStep step14>
    toDtFrac      = 1.0
    messageFields = [ElecFieldBeam]
    updaters      = [yeeAmpereBeam]
  </UpdateStep>
$ endif

  MALdampE_afterAmpere(ElecFieldPlasma, male2yL, 0, 0, 0,      NX, NY_BEG, NZ, 1, -1, YSTART, DY, MAL_DAMP_AMPLITUDE, MAL_DAMP_ORDER)
  MALdampE_afterAmpere(ElecFieldPlasma, male2yU, 0, NY_END, 0, NX, NY,    NZ, 1,  1, YSTART, DY, MAL_DAMP_AMPLITUDE, MAL_DAMP_ORDER)
  MALdampE_afterAmpere(ElecFieldPlasma,male2zL, 0, NY_BEG, 0,      NX, NY_END, NZ_BEG, 2, -1, ZSTART, DZ, MAL_DAMP_AMPLITUDE, MAL_DAMP_ORDER)
  MALdampE_afterAmpere(ElecFieldPlasma,male2zR, 0, NY_BEG, NZ_END, NX, NY_END,    NZ, 2,  1, ZSTART, DZ, MAL_DAMP_AMPLITUDE, MAL_DAMP_ORDER)


$ if BEAM_FIELD_SWITCH == 1
  MALdampE_afterAmpere(ElecFieldBeam, male2yL, 0, 0, 0,      NX, NY_BEG, NZ, 1, -1, YSTART, DY, MAL_DAMP_AMPLITUDE, MAL_DAMP_ORDER)
  MALdampE_afterAmpere(ElecFieldBeam, male2yU, 0, NY_END, 0, NX, NY,    NZ, 1,  1, YSTART, DY, MAL_DAMP_AMPLITUDE, MAL_DAMP_ORDER)
  MALdampE_afterAmpere(ElecFieldBeam,male2zL, 0, NY_BEG, 0,      NX, NY_END, NZ_BEG, 2, -1, ZSTART, DZ, MAL_DAMP_AMPLITUDE, MAL_DAMP_ORDER)
  MALdampE_afterAmpere(ElecFieldBeam,male2zR, 0, NY_BEG, NZ_END, NX, NY_END,    NZ, 2,  1, ZSTART, DZ, MAL_DAMP_AMPLITUDE, MAL_DAMP_ORDER)
$ endif
  <UpdateStep step15>
     toDtFrac      = 1.0
     messageFields = [MagFieldPlasma]
     updaters      = [yeeFaradayPlasma]
  </UpdateStep>

$ if BEAM_FIELD_SWITCH == 1

  <UpdateStep step16>
     toDtFrac      = 1.0
     messageFields = [MagFieldBeam]
     updaters      = [yeeFaradayBeam]
  </UpdateStep>
$ endif

  MALdampB_afterFaraday(MagFieldPlasma, malb2yL, 0, 0, 0,      NX, NY_BEG, NZ, 1, -1, YSTART, DY, MAL_DAMP_AMPLITUDE, MAL_DAMP_ORDER)
  MALdampB_afterFaraday(MagFieldPlasma, malb2yU, 0, NY_END, 0, NX, NY,    NZ, 1,  1, YSTART, DY, MAL_DAMP_AMPLITUDE, MAL_DAMP_ORDER)
  
  MALdampB_afterFaraday(MagFieldPlasma,malb2zL, 0, NY_BEG, 0,      NX, NY_END, NZ_BEG, 2, -1, ZSTART, DZ, MAL_DAMP_AMPLITUDE, MAL_DAMP_ORDER)
  MALdampB_afterFaraday(MagFieldPlasma,malb2zR, 0, NY_BEG, NZ_END, NX, NY_END,    NZ, 2,  1, ZSTART, DZ, MAL_DAMP_AMPLITUDE, MAL_DAMP_ORDER)


$ if BEAM_FIELD_SWITCH == 1
  MALdampB_afterFaraday(MagFieldBeam, malb2yL, 0, 0, 0,      NX, NY_BEG, NZ, 1, -1, YSTART, DY, MAL_DAMP_AMPLITUDE, MAL_DAMP_ORDER)
  MALdampB_afterFaraday(MagFieldBeam, malb2yU, 0, NY_END, 0, NX, NY,    NZ, 1,  1, YSTART, DY, MAL_DAMP_AMPLITUDE, MAL_DAMP_ORDER)
  MALdampB_afterFaraday(MagFieldBeam,malb2zL, 0, NY_BEG, 0,      NX, NY_END, NZ_BEG, 2, -1, ZSTART, DZ, MAL_DAMP_AMPLITUDE, MAL_DAMP_ORDER)
  MALdampB_afterFaraday(MagFieldBeam,malb2zR, 0, NY_BEG, NZ_END, NX, NY_END,    NZ, 2,  1, ZSTART, DZ, MAL_DAMP_AMPLITUDE, MAL_DAMP_ORDER)
$ endif



  MALprofileDump (malb1yL, 0, 0, 0,      NX, NY_BEG, NZ, 1, -1, YSTART, DY, MAL_DAMP_AMPLITUDE, MAL_DAMP_ORDER)
  MALprofileDump (malb1yU, 0, NY_END, 0, NX, NY,    NZ, 1,  1, YSTART, DY, MAL_DAMP_AMPLITUDE, MAL_DAMP_ORDER)
  MALprofileDump (malb1zL, 0, NY_BEG, 0,      NX, NY_END, NZ_BEG, 2, -1, ZSTART, DZ, MAL_DAMP_AMPLITUDE, MAL_DAMP_ORDER)
  MALprofileDump (malb1zR, 0, NY_BEG, NZ_END, NX, NY_END,    NZ, 2,  1, ZSTART, DZ, MAL_DAMP_AMPLITUDE, MAL_DAMP_ORDER)

$ if BEAM_FIELD_SWITCH  == 1
  <UpdateStep step17>
    toDtFrac = 1.0
    messageFields = [ElecMultiField]
    updaters = [sumE1]
  </UpdateStep>
$ endif

$ if BEAM_FIELD_SWITCH == 0
  <UpdateStep step17b>
    toDtFrac = 1.0
    messageFields = [ElecMultiField]
    updaters = [sumE2]
  </UpdateStep>
$ endif

$ if BEAM_FIELD_SWITCH  == 1
  <UpdateStep step18>
    toDtFrac = 1.0
    messageFields = [MagMultiField]
    updaters = [sumB1]
  </UpdateStep>
$ endif
$ if BEAM_FIELD_SWITCH  == 0
  <UpdateStep step18>
    toDtFrac = 1.0
    messageFields = [MagMultiField]
    updaters = [sumB2]
  </UpdateStep>
$ endif

</MultiField>


## --------------------------------------------------
## charge and current depositors
## --------------------------------------------------

<VectorDepositor JDep>
  kind = esirk3rdOrder
  depField = emField.JBeam
</VectorDepositor>

<ScalarDepositor rhoDep>
  kind = esirk3rdOrder
  depField = emField.rhoBeam
</ScalarDepositor>
			 

<VectorDepositor JDepPlasma>
  kind = esirk3rdOrder
  depField = emField.JPlasma
</VectorDepositor>

<ScalarDepositor rhoDepPlasma>
  kind = esirk3rdOrder
  depField = emField.rhoPlasma
</ScalarDepositor>





## --------------------------------------------
## Gas Species
## --------------------------------------------



## HYDROGEN species
# -------------------------------------

$ if H_FLAG == 1

<Species HGas>
  kind   = relBorisVWTagged
  charge = 0.
  mass   = PROTMASS

  fields     = [emField.ElecFieldLaser emField.MagFieldBeam]

  nominalDensity  = H_DENS
  nomPtclsPerCell = PPC_0
  useSegmentedMove = 0



  <ParticleSource slabSrc>
    kind = xvLoaderEmitter
    loadOnShift = true
    loadAfterInit = false

    <PositionGenerator mySlab>
      kind = gridPosGen        # helps reduce noise
      <Slab loadSlab>
        lowerBounds = [$xFOCUS - 100.e-6$  YSTART  $zSHIFT - 100.e-6$]
        upperBounds = [$xFOCUS + 100.e-6$  YEND    $zSHIFT + 100.e-6$]
        doShiftLoad = 1
      </Slab>
      emitSign = 1
      macroPerDir = [NP_X NP_Y NP_Z]
    </PositionGenerator>
	
    <VelocityGenerator slabVelGen>
      kind = funcVelGen
      <STFunc component4>
		kind             = cosineFlattop
		direction        = [0.  1.  0.]
		startPosition    = $YSTART + GAS_DISTANCE_WALLS$
		startFlattop     = $YSTART + GAS_DISTANCE_WALLS + GAS_RAMPLEN$
		endFlattop       = $YEND   - GAS_DISTANCE_WALLS - GAS_RAMPLEN$
		endPosition      = $YEND   - GAS_DISTANCE_WALLS$
		startAmplitude   = 0.
		endAmplitude     = 0.
		flattopAmplitude = 1. 
      </STFunc>
    </VelocityGenerator>
	
	
  </ParticleSource>

# specify particle sinks all around the domain
  absorbingBox(NX, NY, NZ)

</Species>

## HYDROGEN electrons and ions
# -------------------------------------

#  H electrons created by the laser

<Species HElecLaser>
  kind   = relBorisVWTagged
  charge = ELECCHARGE
  mass   = ELECMASS

  fields     = [emField.ElecMultiField emField.MagMultiField]
  currDeps = [JDepPlasma]
  chargeDeps = [rhoDepPlasma]

  nominalDensity  = H_DENS
  nomPtclsPerCell = PPC_0
  useSegmentedMove = 0
  overwriteTag  = true

# specify particle sinks all around the domain
  absorbingBox(NX, NY, NZ)

</Species>

#  H+ ions created  by the laser
<Species HPlusLaser>
  kind   = relBorisVWTagged
  charge = 1.60217657e-19
  mass   = PROTMASS

  fields     = [emField.ElecMultiField emField.MagMultiField]
  currDeps   = [JDepPlasma]
  chargeDeps = [rhoDepPlasma]

  nominalDensity  = H_DENS
  nomPtclsPerCell = PPC_0
  useSegmentedMove = 0
  overwriteTag  = true

# immediately delete the H ions
  <ParticleSink deleteAll>
    kind   = absorber
    lowerBounds = [ -1   -1   -1]
    upperBounds = [NX1  NY1  NZ1]
  </ParticleSink>

 # specify particle sinks all around the domain					
  absorbingBox(NX, NY, NZ)

</Species>



$ endif 	# H_FLAG == 1	





# --------------------------------------------
# Specify the He ion and electron species here
# --------------------------------------------

$ if HE_FLAG == 1

# Mass [kg] of helium ions
$ AMU_MASS = 1.6605389e-27
$ HE_AMU   = 4.0026
$ HE_MASS  = HE_AMU * AMU_MASS

# Specify the neutral He gas
<Species HeGas>
  kind   = relBorisVWTagged
  charge = 0.
  mass   = HE_MASS

  fields   = [emField.ElecFieldLaser emField.MagFieldBeam]

  nominalDensity  = HE_DENS
  nomPtclsPerCell = PPC_0
  useSegmentedMove = 0
  overwriteTag  = true


  <ParticleSource slabSrc>
    kind = xvLoaderEmitter
    loadOnShift = true
    loadAfterInit = false

    <PositionGenerator mySlab>
      kind = gridPosGen        # helps reduce noise
      <Slab loadSlab>
        lowerBounds = [$xFOCUS - 100.e-6$  YSTART  $zSHIFT - 100.e-6$]
        upperBounds = [$xFOCUS + 100.e-6$  YEND    $zSHIFT + 100.e-6$]
        doShiftLoad = 1
      </Slab>
      emitSign = 1
      macroPerDir = [NP_X NP_Y NP_Z]
    </PositionGenerator>
	
	
    <VelocityGenerator slabVelGen>
      kind = funcVelGen
      <STFunc component4>
		kind             = cosineFlattop
		direction        = [0.  1.  0.]
		startPosition    = $YSTART + GAS_DISTANCE_WALLS$
		startFlattop     = $YSTART + GAS_DISTANCE_WALLS + GAS_RAMPLEN$
		endFlattop       = $YEND   - GAS_DISTANCE_WALLS - GAS_RAMPLEN$
		endPosition      = $YEND   - GAS_DISTANCE_WALLS$
		startAmplitude   = 0.
		endAmplitude     = 0.
		flattopAmplitude = 1. 
      </STFunc>
    </VelocityGenerator>
		
	 
	 
 </ParticleSource>
  
  

# specify particle sinks all around the domain
  absorbingBox(NX, NY, NZ)

</Species>

## Helium electrons and ions
# -------------------------------------

#  He electrons created by the laser

<Species HeElecLaser>
  kind   = relBorisVWTagged
  charge = ELECCHARGE
  mass   = ELECMASS

  fields     = [emField.ElecMultiField emField.MagMultiField]
  currDeps   = [JDepPlasma]
  chargeDeps = [rhoDepPlasma]
  overwriteTag  = true

  nominalDensity  = HE_DENS
  nomPtclsPerCell = PPC_0
  useSegmentedMove = 0

# specify particle sinks all around the domain
  absorbingBox(NX, NY, NZ)

</Species>

#  He+ ions created  by the laser
<Species HePlusLaser>
  kind   = relBorisVWTagged
  charge = 1.60217657e-19
  mass   = HE_MASS

  fields     = [emField.ElecMultiField emField.MagMultiField]
  currDeps   = [JDepPlasma]
  chargeDeps = [rhoDepPlasma]

  nominalDensity  = HE_DENS
  nomPtclsPerCell = PPC_0
  useSegmentedMove = 0
  overwriteTag = 1

# immediately delete the H ions
  <ParticleSink deleteAll>
    kind   = absorber
    lowerBounds = [ -1   -1   -1]
    upperBounds = [NX1  NY1  NZ1]
  </ParticleSink>

 # specify particle sinks all around the domain					
  absorbingBox(NX, NY, NZ)

</Species>





$ endif 	# HE_FLAG == 1	






<Species BeamElectrons>
  kind = relBoris
  useSegmentedMove = 0
  
  charge = ELECCHARGE
  mass 	 = ELECMASS
  fields = [emField.ElecMultiField emField.MagMultiField]
  nominalDensity = BEAM_DENSITY
  nomPtclsPerCell = BEAM_PTCLS_PER_CELL

  currDeps =   [JDep]
  chargeDeps = [rhoDep]

  <ParticleSource BeamLoader>
    kind = xvLoaderEmitter
    loadOnShift = false
    loadAfterInit = false

    <PositionGenerator gridSlab>
      kind = bitRevSlabPosGen
      <Slab loadSlab>
     	lowerBounds = [BEAM_LOAD_XSTART  $-MAX_RAD_Y + BEAM_OFFSET_VERT$  $-MAX_RAD_Z+ BEAM_OFFSET_HOR$]
        upperBounds = [BEAM_LOAD_XEND    $ MAX_RAD_Y + BEAM_OFFSET_VERT$  $ MAX_RAD_Z+ BEAM_OFFSET_HOR$]
      </Slab>
      emitSign = 1
      sweepRate = V_X_AVG
      ptclsPerCell = BEAM_PTCLS_PER_CELL
    </PositionGenerator>

    <VelocityGenerator beamVelGen>
      kind = funcVelGen
	  
      # Give the particles a drift velocity

       <STFunc component0>   # distribution of u_x = gamma * v_x [m/s]
         kind = expression
         expression = gauss(U_X_RMS, U_X_AVG)
       </STFunc>
 
       <STFunc component1>   # distribution of u_x = gamma * v_x [m/s]
         kind = expression
         expression = gauss(U_Y_RMS, 0.)
       </STFunc>

       <STFunc component2>   # distribution of u_x = gamma * v_x [m/s]
         kind = expression
         expression = gauss(U_Z_RMS, 0.)
       </STFunc>
	   
    </VelocityGenerator>

    <STFunc relMacroDenFunc>
      kind = expression

	  expression = exp(-0.5*(y - BEAM_OFFSET_VERT)**2 / BEAM_RMS_WIDTH_Y**2)	\
		     * exp(-0.5*(z - BEAM_OFFSET_HOR )**2 / BEAM_RMS_WIDTH_Z**2)        \
		     * exp(-0.5*(x - BEAM_CENTER     )**2 / BEAM_RMS_LENGTH**2 )
    </STFunc>	

  </ParticleSource>

  absorbingBox(NX, NY, NZ)

</Species>





# ------------------------------------------------
# Monte Carlo Interactions
# ------------------------------------------------


# ------------------------------------------------
# Ionization block for H, He and Li (VSim 6.0 syntax)
# ------------------------------------------------

<MonteCarloInteractions laserIonizer>

  # must have one of these
  <IncidentSelector mySelector>
    kind=unbiasedSelector
  </IncidentSelector>

$ if H_FLAG == 1

	$ if LASER_IONIZATION == 1

		# TI of neutral H particles
		<Interaction fieldHIonization>
			kind      = fieldIonization
			input     = HGas
			ions      = HPlusLaser
			electrons = HElecLaser
			energy  = 13.6       # correct ionization potential
			charge    = 0        # charge before ionization
			ionizationKind = averagedADK       
			polarizationFlag = 0
		</Interaction>

	$ endif
	
  
$ endif	 #H_FLAG == 1
 
$ if HE_FLAG == 1

	$ if LASER_IONIZATION == 1
  	      <Interaction fieldHeIonization>
   		 kind      = fieldIonization
   		 input     = HeGas
   		 ions      = HePlusLaser
  		 electrons = HeElecLaser
  		 energy  = 24.59      # correct ionization potential
  		 charge    = 0                 # charge before ionization
  		 ionizationKind = averagedADK     
	      </Interaction>
	$ endif
	
  
$ endif #HE_FLAG == 1


</MonteCarloInteractions>
















